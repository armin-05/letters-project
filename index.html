<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shape Writer</title>
<style>
  body {
    background-color: black;
    overflow: hidden;
    margin: 0;
  }

  canvas {
    display: block;
    background: black;
    margin: 0 auto;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let x = 100, y = 100;
const colSpacing = 150;
const rowSpacing = 150;
let currentRow = 0;
let currentCol = 0;
let history = [[[]]]; // columns -> rows -> shapes
let scale = 1;

function adjustZoom() {
  const margin = 150;
  const maxX = (currentCol + 1) * colSpacing;
  const maxY = (currentRow + 1) * rowSpacing;

  const fitsX = maxX * scale < window.innerWidth - margin;
  const fitsY = maxY * scale < window.innerHeight - margin;

  if (!fitsX || !fitsY) {
    scale *= 0.9;
  } else if (fitsX && fitsY && scale < 1) {
    scale *= 1.05;
    if (scale > 1) scale = 1;
  }

  ctx.setTransform(scale, 0, 0, scale, 0, 0);
}

function drawShape(letter, posX, posY) {
  const size = 60;
  ctx.strokeStyle = "rgba(255,0,0,0.55)";
  ctx.fillStyle = "rgba(255,0,0,0.55)";
  ctx.lineWidth = 12;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();

  const L = letter.toUpperCase();

  switch (L) {
    case 'Q':
      ctx.arc(posX, posY, size / 2, 0, Math.PI * 2);
      ctx.moveTo(posX - size / 2, posY);
      ctx.lineTo(posX + size / 2, posY);
      break;
    case 'W':
      for (let i = -1; i <= 1; i++) {
        ctx.moveTo(posX + i * 20, posY - 40);
        ctx.lineTo(posX + i * 20, posY + 40);
      }
      break;
    case 'E':
      for (let i = -1; i <= 1; i++) {
        ctx.moveTo(posX - 40, posY + i * 20);
        ctx.lineTo(posX + 40, posY + i * 20);
      }
      break;
    case 'R': // circle with vertical line
      ctx.arc(posX, posY, size / 2, 0, Math.PI * 2);
      ctx.moveTo(posX, posY - size / 2);
      ctx.lineTo(posX, posY + size / 2);
      break;
    case 'T':
      ctx.moveTo(posX - 40, posY - 40);
      ctx.lineTo(posX + 40, posY - 40);
      ctx.moveTo(posX, posY - 40);
      ctx.lineTo(posX, posY + 40);
      break;
    case 'Y': // 3-way branch
      ctx.moveTo(posX, posY);
      ctx.lineTo(posX, posY - 40);
      ctx.moveTo(posX, posY);
      ctx.lineTo(posX - 30, posY + 40);
      ctx.moveTo(posX, posY);
      ctx.lineTo(posX + 30, posY + 40);
      break;
    case 'U':
      ctx.moveTo(posX - 40, posY - 10);
      ctx.lineTo(posX + 40, posY - 10);
      ctx.moveTo(posX - 40, posY + 10);
      ctx.lineTo(posX + 40, posY + 10);
      break;
    case 'I':
      ctx.moveTo(posX, posY - 40);
      ctx.lineTo(posX, posY + 40);
      break;
    case 'O':
      ctx.arc(posX, posY, size / 2, 0, Math.PI * 2);
      break;
    case 'P': // smaller circle
      ctx.arc(posX, posY, size / 3, 0, Math.PI * 2);
      break;
    case 'A': // larger triangle
      const h = Math.sqrt(3) * (size / 1.2);
      ctx.moveTo(posX, posY - h / 2);
      ctx.lineTo(posX - size / 1.2, posY + h / 2);
      ctx.lineTo(posX + size / 1.2, posY + h / 2);
      ctx.closePath();
      break;
    case 'S': // "8"
      ctx.arc(posX, posY - 25, 20, 0, Math.PI * 2);
      ctx.moveTo(posX, posY + 25);
      ctx.arc(posX, posY + 25, 20, 0, Math.PI * 2);
      break;
    case 'D': // Infinity
      ctx.moveTo(posX - 25, posY);
      ctx.bezierCurveTo(posX - 50, posY - 25, posX, posY - 25, posX + 25, posY);
      ctx.bezierCurveTo(posX + 50, posY + 25, posX, posY + 25, posX - 25, posY);
      break;
    case 'H': // rounded X-like cross
      ctx.moveTo(posX - 30, posY - 30);
      ctx.lineTo(posX + 30, posY + 30);
      ctx.moveTo(posX + 30, posY - 30);
      ctx.lineTo(posX - 30, posY + 30);
      break;
    case 'J': // Y shape
      ctx.moveTo(posX, posY);
      ctx.lineTo(posX, posY + 40);
      ctx.moveTo(posX, posY);
      ctx.lineTo(posX - 30, posY - 40);
      ctx.moveTo(posX, posY);
      ctx.lineTo(posX + 30, posY - 40);
      break;
    case 'K': // star-like X
      ctx.moveTo(posX - 30, posY);
      ctx.lineTo(posX + 30, posY);
      ctx.moveTo(posX, posY - 30);
      ctx.lineTo(posX, posY + 30);
      break;
    case 'L': // vertical + mid line
      ctx.moveTo(posX, posY - 40);
      ctx.lineTo(posX, posY + 40);
      ctx.moveTo(posX - 25, posY);
      ctx.lineTo(posX + 25, posY);
      break;
    case 'Z': // 3 horizontal lines
      ctx.moveTo(posX - 40, posY - 30);
      ctx.lineTo(posX + 40, posY - 30);
      ctx.moveTo(posX - 30, posY);
      ctx.lineTo(posX + 30, posY);
      ctx.moveTo(posX - 20, posY + 30);
      ctx.lineTo(posX + 20, posY + 30);
      break;
    case 'C': // sideways 8
      ctx.moveTo(posX - 25, posY);
      ctx.bezierCurveTo(posX - 50, posY - 25, posX, posY - 25, posX + 25, posY);
      ctx.bezierCurveTo(posX + 50, posY + 25, posX, posY + 25, posX - 25, posY);
      break;
    case 'B': // small 8
      ctx.arc(posX, posY - 20, 18, 0, Math.PI * 2);
      ctx.moveTo(posX, posY + 20);
      ctx.arc(posX, posY + 20, 18, 0, Math.PI * 2);
      break;
    case 'F':
      ctx.moveTo(posX - 40, posY - 10);
      ctx.lineTo(posX + 40, posY - 10);
      ctx.moveTo(posX - 40, posY + 10);
      ctx.lineTo(posX + 40, posY + 10);
      break;
    case 'G':
      ctx.arc(posX, posY, 5, 0, Math.PI * 2);
      break;
    case 'N': // heart
      ctx.moveTo(posX, posY);
      ctx.bezierCurveTo(posX - 30, posY - 30, posX - 60, posY + 20, posX, posY + 50);
      ctx.bezierCurveTo(posX + 60, posY + 20, posX + 30, posY - 30, posX, posY);
      break;
    case 'M': // mirrored M
      ctx.moveTo(posX - 40, posY + 60);
      ctx.lineTo(posX - 40, posY - 60);
      ctx.lineTo(posX, posY);
      ctx.lineTo(posX + 40, posY - 60);
      ctx.lineTo(posX + 40, posY + 60);
      break;
    default:
      return;
  }

  ctx.stroke();
}

function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let c = 0; c < history.length; c++) {
    for (let r = 0; r < history[c].length; r++) {
      history[c][r].forEach(l => {
        drawShape(l, 100 + c * colSpacing, 100 + r * rowSpacing);
      });
    }
  }
}

document.addEventListener('keydown', (e) => {
  const key = e.key;

  if (/^[a-zA-Z]$/.test(key)) {
    drawShape(key, x, y);
    history[currentCol][currentRow].push(key);
  } else if (key === ' ') {
    currentRow++;
    if (!history[currentCol][currentRow]) history[currentCol][currentRow] = [];
    y += rowSpacing;
  } else if (key === 'Enter') {
    currentCol++;
    currentRow = 0;
    if (!history[currentCol]) history[currentCol] = [[]];
    x += colSpacing;
    y = 100;
  } else if (key === 'Backspace') {
    e.preventDefault();
    const currentShapes = history[currentCol][currentRow];
    if (currentShapes.length > 0) {
      history[currentCol][currentRow] = [];
      redraw();
    } else if (currentRow > 0) {
      currentRow--;
      y -= rowSpacing;
      redraw();
    } else if (currentCol > 0) {
      currentCol--;
      x -= colSpacing;
      currentRow = history[currentCol].length - 1;
      y = 100 + rowSpacing * currentRow;
      redraw();
    }
  }

  adjustZoom();
});
</script>
</body>
</html>
