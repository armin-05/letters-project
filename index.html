<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shape Writer</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block;background:#000;width:100%;height:100%}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function fitCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
fitCanvas();
addEventListener('resize',()=>{fitCanvas(); recomputeZoomAndDraw();});

const baseX = 100;
const baseY = 100;
const size = 72;
const colSpacing = 150;
const rowSpacing = 150;
const margin = 40;
let scale = 1;

let currentCol = 0;
let currentRow = 0;
let history = [[[]]]; // columns -> rows -> array of letters

function addCellIfMissing(col, row){
  if(!history[col]) history[col]=[];
  if(!history[col][row]) history[col][row]=[];
}

function drawShape(letter, cx, cy){
  const s = size;
  ctx.strokeStyle = "rgba(255,0,0,0.55)";
  ctx.fillStyle = "rgba(255,0,0,0.55)";
  ctx.lineWidth = Math.max(6, s * 0.13);
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  const L = letter.toUpperCase();
  if(L === 'Q'){
    ctx.arc(cx,cy,s/2,0,Math.PI*2);
    ctx.moveTo(cx - s/2, cy); ctx.lineTo(cx + s/2, cy);
  } else if(L === 'W'){
    for(let i=-1;i<=1;i++) ctx.moveTo(cx + i*20, cy - s/2, ), ctx.lineTo(cx + i*20, cy + s/2);
  } else if(L === 'E'){
    for(let i=-1;i<=1;i++) ctx.moveTo(cx - s/2, cy + i*20), ctx.lineTo(cx + s/2, cy + i*20);
  } else if(L === 'R'){
    ctx.arc(cx,cy,s/2,0,Math.PI*2);
    ctx.moveTo(cx, cy - s/2); ctx.lineTo(cx, cy + s/2);
  } else if(L === 'T'){
    ctx.moveTo(cx - s/2, cy - s/2); ctx.lineTo(cx + s/2, cy - s/2);
    ctx.moveTo(cx, cy - s/2); ctx.lineTo(cx, cy + s/2);
  } else if(L === 'Y'){
    ctx.moveTo(cx,cy); ctx.lineTo(cx, cy - s/2);
    ctx.moveTo(cx,cy); ctx.lineTo(cx - s*0.45, cy + s*0.45);
    ctx.moveTo(cx,cy); ctx.lineTo(cx + s*0.45, cy + s*0.45);
  } else if(L === 'U'){
    ctx.moveTo(cx - s/2, cy - 10); ctx.lineTo(cx + s/2, cy - 10);
    ctx.moveTo(cx - s/2, cy + 10); ctx.lineTo(cx + s/2, cy + 10);
  } else if(L === 'I'){
    ctx.moveTo(cx, cy - s/2); ctx.lineTo(cx, cy + s/2);
  } else if(L === 'O'){
    ctx.arc(cx,cy,s/2,0,Math.PI*2);
  } else if(L === 'P'){
    ctx.arc(cx,cy,s*0.35,0,Math.PI*2);
  } else if(L === 'A'){
    const h = Math.sqrt(3) * (s/1.1) / 2;
    ctx.moveTo(cx, cy - h);
    ctx.lineTo(cx - s/1.1, cy + h);
    ctx.lineTo(cx + s/1.1, cy + h);
    ctx.closePath();
    ctx.stroke();
    ctx.fill();
    return;
  } else if(L === 'S'){
    const r = s*0.22;
    const offset = s*0.35;
    ctx.arc(cx, cy - offset, r, 0, Math.PI*2);
    ctx.moveTo(cx + r, cy - offset);
    ctx.arc(cx, cy + offset/2, r, 0, Math.PI*2);
    ctx.moveTo(cx + r, cy + offset/2);
    ctx.arc(cx - offset*0.5, cy + offset*1.1, r, 0, Math.PI*2);
  } else if(L === 'D'){
    const r = s*0.28;
    ctx.arc(cx, cy - r, r, 0, Math.PI*2);
    ctx.moveTo(cx + r, cy - r);
    ctx.arc(cx, cy + r, r, 0, Math.PI*2);
  } else if(L === 'F'){
    ctx.moveTo(cx - s/2, cy - s*0.12); ctx.lineTo(cx + s/2, cy - s*0.12);
    ctx.moveTo(cx - s/2, cy + s*0.12); ctx.lineTo(cx + s/2, cy + s*0.12);
  } else if(L === 'G'){
    ctx.arc(cx, cy, Math.max(3, s*0.06), 0, Math.PI*2);
  } else if(L === 'H'){
    const a = s*0.42;
    ctx.moveTo(cx - a, cy - a); ctx.lineTo(cx + a, cy + a);
    ctx.moveTo(cx + a, cy - a); ctx.lineTo(cx - a, cy + a);
    ctx.moveTo(cx - a, cy); ctx.lineTo(cx + a, cy);
  } else if(L === 'J'){
    ctx.moveTo(cx - s*0.45, cy - s*0.5); ctx.lineTo(cx + s*0.45, cy - s*0.5);
    ctx.moveTo(cx, cy - s*0.5); ctx.lineTo(cx, cy + s*0.5);
    ctx.moveTo(cx - s*0.45, cy + s*0.5); ctx.lineTo(cx + s*0.45, cy + s*0.5);
  } else if(L === 'K'){
    const a = s*0.35;
    ctx.moveTo(cx - a, cy); ctx.lineTo(cx + a, cy);
    ctx.moveTo(cx, cy - a); ctx.lineTo(cx, cy + a);
  } else if(L === 'L'){
    ctx.moveTo(cx, cy - s/2); ctx.lineTo(cx, cy + s/2);
    ctx.moveTo(cx - s*0.35, cy); ctx.lineTo(cx + s*0.35, cy);
  } else if(L === 'Z'){
    ctx.moveTo(cx - s/2, cy - s*0.3); ctx.lineTo(cx + s/2, cy - s*0.3);
    ctx.moveTo(cx, cy); ctx.arc(cx, cy, Math.max(3, s*0.06), 0, Math.PI*2);
    ctx.moveTo(cx - s/3, cy + s*0.3); ctx.lineTo(cx + s/3, cy + s*0.3);
  } else if(L === 'X'){
    const a = s*0.45;
    ctx.moveTo(cx - a, cy - a); ctx.lineTo(cx - a*0.25, cy - a*0.25);
    ctx.moveTo(cx + a, cy - a); ctx.lineTo(cx + a*0.25, cy - a*0.25);
    ctx.moveTo(cx - a, cy + a); ctx.lineTo(cx - a*0.25, cy + a*0.25);
    ctx.moveTo(cx + a, cy + a); ctx.lineTo(cx + a*0.25, cy + a*0.25);
  } else if(L === 'C'){
    ctx.moveTo(cx + s*0.4, cy - s*0.4);
    ctx.bezierCurveTo(cx - s*0.5, cy - s*0.5, cx - s*0.5, cy + s*0.5, cx + s*0.4, cy + s*0.4);
  } else if(L === 'V'){
    ctx.moveTo(cx - s*0.45, cy - s*0.45); ctx.lineTo(cx, cy + s*0.45); ctx.lineTo(cx + s*0.45, cy - s*0.45);
  } else if(L === 'B'){
    const r = s*0.18;
    const off = s*0.22;
    ctx.arc(cx - off, cy - off, r, 0, Math.PI*2);
    ctx.moveTo(cx + off - r, cy - off);
    ctx.arc(cx + off, cy - off, r, 0, Math.PI*2);
    ctx.moveTo(cx - off, cy + off - r);
    ctx.arc(cx - off, cy + off, r, 0, Math.PI*2);
    ctx.moveTo(cx + off - r, cy + off);
    ctx.arc(cx + off, cy + off, r, 0, Math.PI*2);
  } else if(L === 'N'){
    ctx.moveTo(cx, cy);
    ctx.bezierCurveTo(cx - s*0.4, cy - s*0.35, cx - s*0.8, cy + s*0.2, cx, cy + s*0.5);
    ctx.bezierCurveTo(cx + s*0.8, cy + s*0.2, cx + s*0.4, cy - s*0.35, cx, cy);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    return;
  } else if(L === 'M'){
    ctx.moveTo(cx - s*0.45, cy - s*0.45); ctx.lineTo(cx - s*0.45, cy + s*0.45);
    ctx.arc(cx, cy, Math.max(3, s*0.06), 0, Math.PI*2);
    ctx.moveTo(cx + s*0.45, cy - s*0.45); ctx.lineTo(cx + s*0.45, cy + s*0.45);
  } else {
    return;
  }
  ctx.stroke();
}

function redraw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,0,0);
  ctx.beginPath();
  ctx.fillStyle = "rgba(255,0,0,0.18)";
  ctx.arc(baseX*0.08, baseY*0.08, 4,0,Math.PI*2);
  ctx.fill();
  for(let c=0;c<history.length;c++){
    for(let r=0;r<history[c].length;r++){
      const arr = history[c][r]||[];
      if(arr.length===0) continue;
      const cx = baseX + c*colSpacing;
      const cy = baseY + r*rowSpacing;
      for(let i=0;i<arr.length;i++){
        drawShape(arr[i], cx, cy);
      }
    }
  }
}

function computeBoundingBox(){
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(let c=0;c<history.length;c++){
    for(let r=0;r<history[c].length;r++){
      const arr = history[c][r]||[];
      if(arr.length===0) continue;
      const cx = baseX + c*colSpacing;
      const cy = baseY + r*rowSpacing;
      const ext = size/2 + 10;
      minX = Math.min(minX, cx - ext);
      minY = Math.min(minY, cy - ext);
      maxX = Math.max(maxX, cx + ext);
      maxY = Math.max(maxY, cy + ext);
    }
  }
  if(minX===Infinity) return null;
  return {minX,minY,maxX,maxY,width: maxX-minX,height: maxY-minY};
}

function recomputeZoomAndDraw(){
  const bbox = computeBoundingBox();
  if(!bbox){
    scale = 1;
    redraw();
    return;
  }
  const availW = window.innerWidth - margin*2;
  const availH = window.innerHeight - margin*2;
  let required = 1;
  if(bbox.width > availW || bbox.height > availH){
    required = Math.min(availW / bbox.width, availH / bbox.height);
    if(required > 1) required = 1;
  } else {
    required = 1;
  }
  scale = required;
  redraw();
}

addEventListener('keydown', (e)=>{
  if(e.key === ' '){ e.preventDefault(); currentRow++; addCellIfMissing(currentCol,currentRow); recomputeZoomAndDraw(); return; }
  if(e.key === 'Enter'){ e.preventDefault(); currentCol++; currentRow = 0; addCellIfMissing(currentCol,currentRow); recomputeZoomAndDraw(); return; }
  if(e.key === 'Backspace'){ e.preventDefault();
    addCellIfMissing(currentCol,currentRow);
    if(history[currentCol][currentRow] && history[currentCol][currentRow].length>0){
      history[currentCol][currentRow] = [];
      recomputeZoomAndDraw();
      return;
    }
    if(currentRow > 0){
      currentRow--;
      recomputeZoomAndDraw();
      return;
    }
    if(currentCol > 0){
      currentCol--;
      currentRow = (history[currentCol].length-1)>=0 ? history[currentCol].length-1 : 0;
      if(!history[currentCol][currentRow]) history[currentCol][currentRow]=[];
      recomputeZoomAndDraw();
      return;
    }
    return;
  }
  if(/^[a-zA-Z]$/.test(e.key)){
    addCellIfMissing(currentCol,currentRow);
    history[currentCol][currentRow].push(e.key);
    recomputeZoomAndDraw();
    return;
  }
});

redraw();
</script>
</body>
</html>
